\documentclass[parskip=half]{scrartcl}
\usepackage[english,ngerman]{babel}
\usepackage[latin1]{inputenc}                
\usepackage[T1]{fontenc}  
\usepackage{lmodern}
\usepackage{graphicx}

\begin{document}
% ----------------------------------------------------------------------------
% Titel 
%\titlehead{Deutsches Zentrum für Luft- und Raumfahrt e.V.}
%\subject{Art des Dokuments}
\title{Automatisierung und Kreativität}
\subtitle{Ist die Grenze beherrschbarer Komplexität erreicht?}
\author{Dr. Robert Hilbrich}
\date{}
%\publishers{Platz für Betreuer o.\,ä.}
\maketitle
% ----------------------------------------------------------------------------
% Inhaltsverzeichnis:
%\tableofcontents
% ----------------------------------------------------------------------------
% Gliederung und Text:

\section{Einführung}
\label{sec:einfuhrung}

Der technologische Fortschritt unserer Gesellschaft spiegelt sich in der hohen Leistungsfähigkeit unserer Fahrzeuge wider.
Piloten müssen ihre tonnenschweren Flugzeuge heute nur noch indirekt steuern, in dem sie über einen kleinen Joystick mit dem Steuerungssystem interagieren.
Die Komplexität der richtigen Ansteuerung von Höhen"=, Seiten"= und Querruder bei gleichzeitiger Anpassung der Schubkraft tritt fast vollkommen in den Hintergrund.
Autofahrer können sich durch eine Vielzahl von Assistenzsystemen bei der Fahrt unterstützen lassen.
Unliebsame Aufgaben können sie an den \emph{Autobahn-Piloten}, den \emph{Stau}-Assistenten oder den \emph{Park}-Assistenten delegieren. 
Der Schritt zu voll"=automatischen Fahrzeugen ist nicht mehr weit.

Der \emph{Computer} in seiner Rolle als automatisiertes Steuersystem nimmt dem Menschen immer mehr Aufgaben ab.
Dies betrifft insbesondere Aufgaben, von denen unsere persönliche Sicherheit abhängt.
Ein kleiner Fehler im Steuerungssystem eines Flugzeugs -- zum Beispiel ein kleiner Zeitversatz zwischen der Ansteuerung des linken und rechten Höhenruders -- kann bereits genügen, um das Flugzeug in einen aerodynamisch instabilen Zustand zu bringen.
Im Auto können Ungenauigkeiten bei der Spur"=Erkennung eines \emph{Autobahn"=Piloten} schnell katastrophale Folgen haben.

Trotz dieser Risiken übergeben wir die Verantwortung für unser Wohlergehen immer häufiger an Computersysteme und vertrauen auf deren Zuverlässigkeit.
Die Statistik der Aus"= und Unfälle belegt, dass diese Entscheidung rückblickend richtig war.
In Anbetracht der sprunghaften technologischen Entwicklungen in den letzten Jahren stellt sich jedoch die Frage, ob dieses Vertrauen auch \emph{zukünftig} gerechtfertigt ist.
Sind unsere Entwicklungsmethoden und "=werkzeuge auch zukünftig "`mächtig"' genug, um die Komplexität der Entwicklung derartiger Systeme sicher zu beherrschen?

Die Steuersysteme im Auto und Flugzeug bestehen aus vielen vernetzten Computern.
Sie interagieren mit zahlreichen Sensoren und Aktuatoren, um ihre Aufgaben zu erfüllen.
Ein vollwertiges "`Fly-by-Wire"' Flugleitsystem für Verkehrsflugzeuge setzt sich aus über 40 vernetzten Computern zusammen, die jeweils für die Durchführung und Überwachung der Ansteuerung einzelner Steuerflächen verantwortlich sind (siehe Abb.~\ref{fig:fcs}).

\begin{figure}[h!tbp]
  \centering
  \includegraphics[width=\textwidth]{gfx/fcs.png}
  \caption{Steuerflächen eines modernen Steuersystems in einem Verkehrsflugzeug}
  \label{fig:fcs}
\end{figure}

Moderne Fahrzeuge beinhalten nicht selten mehr als 75 Computer, um die Vielzahl an Funktionen zu realisieren.
Die Entwicklung derartiger Steuersysteme gerät in Anbetracht dieser Komplexität an ihre Grenzen.
Sie ist gefordert, alle Funktionen unter Berücksichtigung verschiedener denkbarer Umgebungsbedingungen und "=zustände zu realisieren und dabei eine maximale Zuverlässigkeit bei minimalen Kosten zu erzielen.

Diese Komplexität ist ohne den Einsatz von Computer in der Entwicklung nicht mehr zu bewältigen.
Obwohl sich das Einsatzspektrum der Computer in der Systementwicklung in den letzten Jahren deutlich erweitert hat, ist die grundlegende Arbeitsteilung zwischen dem menschlichen Entwickler und seinem elektronischen Assistenten noch immer unverändert.
Während der Computer die wiederkehrenden \emph{Routine"=} und \emph{Analyseaufgaben} übernimmt, bleiben die \emph{kreativ"=konstruktiven Tätigkeiten} dem Menschen überlassen.
Der Mensch erschafft mit seiner Arbeit etwas Neues und Originelles -- zum Beispiel die Architektur einer neuen Flugsteuerung oder einen Algorithmus für eine neue Assistenzfunktion.
Erst die Transformation dieser neuen "`Artefakte"' in Maschinencode und deren Analyse auf Programmierfehler wird durch den Computer durchgeführt. 

Aufgrund dieser Arbeitsteilung ist die Komplexität der zu entwickelnden Systeme durch die menschliche Verarbeitungskapazität begrenzt, denn der Entwickler kann nur eine begrenzte Zahl an Anforderungen an ein neu zu entwickelndes System verarbeiten und diese auch nur mit einer begrenzten Zahl zur Verfügung stehender "`Lösungsbausteine"' in Übereinkunft bringen. 
Eine vollständige und fehlerlose Berücksichtigung \emph{aller} Anforderungen bei der Systementwicklung übersteigt bereits heute in vielen Fällen die Verarbeitungskapazität der Entwickler.

Spätestens mit der Nutzung der neuen \emph{Mehrkernprozessoren} ist die Grenze der sicher beherrschbaren Komplexität überschritten.
Während klassische \emph{Einkernprozessoren} die Ausführung von nur \emph{einer} Softwarekomponente zu jedem Zeitpunkt ermöglichten und daher auch nur eine kleine Anzahl an Softwarekomponenten pro Prozessor integriert werden konnte, bieten \emph{Mehrkernprozessoren} aufgrund ihrer deutlich gestiegenen Rechenleistung mehr Flexibilität.   
Mit Hilfe ihrer unabhängig arbeitenden Rechenkerne ermöglichen sie erstmals eine \emph{parallele Ausführung} verschiedener Softwarekomponenten zur gleichen Zeit, so dass -- zumindest theoretisch -- wesentlich mehr Softwarekomponenten auf einem Prozessor integeriert werden können.  
Mittlerweile sind Mehrkernprozessoren mit über 1000 parallel arbeitenden Rechenkernen frei verfügbar.
Im Vergleich zu den klassischen \emph{Einkernprozessorenn} versprechen sie eine deutliche Steigerung der Rechenleistung bei einem äußerst geringen Energieverbrauch und stellen damit vielversprechende "`Lösungsbausteine"' für die Steuersysteme der Zukunft dar. 
Allerdings überschreitet eine präzise und vollständige a~priori Abschätzung \emph{aller} Auswirkungen dieser starken Konzentration von Softwarekomponenten auf einem Mehrkernprozessor und der daraus resultierenden Ressourcenkonkurrenz das Vermögen menschlicher Entwickler.
Sie können die Zuverlässigkeit eines Systementwurfs auf Basis von Mehrkernprozessoren nur noch sehr eingeschränkt beurteilen.   

Derart hochkomplexe Systeme führen nicht nur die menschliche Entwicklungsarbeit an ihre Grenzen.
Auch die automatisierten Verfahren zum Testen der Neuentwicklungen sind dieser hohen Komplexität nicht mehr vollumfänglich gewachsen.
Wurde bisher die Korrektheit eines Systems durch die extrinsische Beobachtung seines funktionalen Verhaltens getestet, genügt dies heute nicht mehr.
Die Zeit, die dann für die Prüfung aller System"= und Umgebungszustände benötigt werden würde, übersteigt die vorgesehene Entwicklungszeit häufig um ein Vielfaches.
Daher lässt sich der Nachweis über die \emph{vollständige} Korrektheit eines Steuersystems unter \emph{allen} Randbedingungen nicht mehr allein durch die Beobachtung von dessen Verhalten erbringen.

Dies bedeutet, mit Blick auf die gewachsenen Ansprüche an die Funktionalität und die Effizienz von Steuersystemen ist die Grenze der Mächtigkeit der etablierten Entwicklungsmethoden und "=werkzeuge erreicht.
Ihre Weiterentwicklung ist die Voraussetzung, um auch zukünftig effiziente Steuersysteme mit einem erweiterten Funktionsumfang bei gleichzeitiger Aufrechterhaltung einer hohen Zuverlässigkeit zu konstruieren.

Ein möglicher Ansatz zur Lösung dieser Problematik liegt in der \emph{Automatisierung} der kreativ"=konstruktiven Tätigkeiten. 
Dies bricht mit der traditionellen Arbeitsteilung in der Entwicklung.
Bei diesem Ansatz besteht die Aufgabe des menschlichen Entwicklers darin, die Anforderungen an das zu entwickelnde Steuersystem vollständig, präzise und fehlerfrei zu beschreiben.
Im Anschluss konstruiert der Computer unter Zuhilfenahme der verfügbaren Lösungsbausteine automatisiert ein geeignetes "`Artefakt"', das alle gestellten Anforderungen erfüllt.

Vorteile dieses Ansatzes liegen zum einen darin, dass Computer in der Lage sind, die gestellten Anforderungen \emph{vollständiger} und \emph{präziser} mit den technischen Möglichkeiten in Übereinkunft zu bringen.
Die Grenze der beherrschbaren Komplexität lässt sich damit nach oben verschieben.
Zum anderen eröffnet die Automatisierung der Konstruktion die Möglichkeit, die Korrektheit eines Systems auf der Grundlage seines Konstruktionsprozesses zu begründen anstatt dafür eine unvollständige Beobachtung des Systemverhaltens zu verwenden.
Daher ist die Automatisierung der kreativ"=konstruktiven Tätigkeiten eine zentrale Herausforderung für die ingenieurwissenschaftliche Forschung im Bereich der Systementwicklung, um die Weiterentwicklung von Steuersystemen zu ermöglichen und auch zukünftig deren Zuverlässigkeit zu gewährleisten.  

Die zugrunde liegende Dissertation befasst sich mit der automatisierten Konstruktion eines zentralen "`Artefakts"' eines Steuersystems: der Platzierung der verschiedenen Softwarekomponenten auf den Computern eines Steuersystems.
Diese Zuweisung von "`Ressourcen"', wie beispielsweise Rechenzeit auf einem Prozessorkern oder einem Bereich im Arbeitsspeicher, zu einer Softwarekomponente ist scheinbar unspektakulär, doch dieser Eindruck trügt.
Ein Steuersystem kann seine Funktion meist nur dann erbringen, wenn seine Softwarekomponenten die "`richtigen"' Ressourcen in "`ausreichender"' Menge zum "`richtigen"' Zeitpunkt bekommen.
Wenn die Softwarekomponente zur Auslösung der Airbags im Auto beispielsweise nicht rechtzeitig Rechenzeit auf dem Prozessor bekommt, dann besteht die Gefahr einer verzögerten Auslösung.
Die Schutzfunktion des Airbags ist damit gefährdet. 

Neben der korrekten Berücksichtigung von solchen zeitkritischen Softwarekomponenten, muss die Konstruktion einer Platzierung von Softwarekomponenten auch die Auswirkungen auf die Zuverlässigkeit in Betracht ziehen.
So wird bei Steuersystemen eine hohe Zuverlässigkeit meist durch den Einsatz redundant arbeitender Softwarekomponenten realisiert. 
Sobald eine Komponente bedingt durch einen technischen Fehler ausfällt, kann eine andere Komponente dessen Aufgaben übernehmen.
Dies funktioniert selbstverständlich nur dann, wenn alle redundanten Softwarekomponenten auf \emph{unterschiedlichen} Prozessoren platziert wurden.
Eine "`richtige"' und "`ausreichende"' Zuweisung von Ressourcen ist daher für ein Steuersystem -- und auch für viele andere Systeme -- von \emph{essentieller} Bedeutung.
Die Entwicklung einer Zuweisung steht daher in dem Zielkonflikt, einerseits eine hohe Zuverlässigkeit durch die Verwendung möglichst vieler Prozessoren gewährleisten zu müssen und andererseits eine hohe Integration von Softwarekomponenten auf möglichst wenigen Prozessoren zu realisieren.
  
Die Konstruktion einer Ressourcenzuweisung für alle Softwarekomponenten eines Steuersystems ist sehr aufwändig und fehlerträchtig.
Dazu müssen bereits während der Entwicklung \emph{alle} theoretisch möglichen Ausfälle technischer Komponenten adäquat berücksichtigt und \emph{alle} Ressourcenzugriffe der zeitkritischen Softwarekomponenten koordiniert werden.
Dies erfordert ein präzises und vollständiges Verständnis sowohl der Ressourcenbedarfe \emph{aller} Softwarekomponenten als auch der Kapazitäten und Eigenschaften \emph{aller} verfügbaren Ressourcen -- zum Beispiel Prozessoren, Speicherbusse, Gerätecontroller, \dots. 
Während eine solche Ressourcenzuweisung in der Vergangenheit noch manuell konstruiert werden konnte, ist dies bei Mehrkernprozessoren nicht länger sinnvoll möglich.
Das resultierende Komplexitätsniveau macht eine Weiterentwicklung der etablierten Verfahren zwingend notwendig. 
Vor dem Hintergrund dieser Herausforderung wird in der zugrunde liegenden Dissertation ein \emph{automatisiertes Verfahren} zur Konstruktion einer Ressourcenzuweisung entwickelt.
Dieses Verfahren wird als Software"=Werkzeug umgesetzt und anhand von zwei Fallbeispielen aus der Luft- und Raumfahrt erprobt.

Die gesellschaftliche Bedeutung der Ergebnisse der zugrunde liegenden Arbeit ist zweischichtig.
Zum einen belegen die Ergebnisse, dass sich auch komplexe kreativ"=konstruktive Entwicklungsaufgaben automatisieren lassen.
In kürzerer Zeit können effizientere und optimierte Steuersysteme entwickelt werden, ohne dabei unbeabsichtigte Beeinträchtigungen in der Zuverlässigkeit befürchten zu müssen.
Das Niveau der beherrschbaren Komplexität wird durch das entwickelte Verfahren signifikant angehoben.

Mittlerweile wird dieses Verfahren in leicht angepasster Form bei einem Hersteller ziviler Flugzeuge zur Optimierung der Systemarchitektur eines Flugzeugtyps produktiv eingesetzt.
Durch den Einsatz des Software"=Werkzeugs konnte die benötigte Zeitdauer für die Konstruktion \emph{einer} vollständigen und fehlerfreien Zuweisung von ehemals ca. 12-15~Monaten auf den Zeitraum von etwa 5~Minuten reduziert werden.
In der Folge konnten erstmals viele unterschiedliche Zuweisungen konstruiert und miteiander verglichen werden, so dass letztendlich auch Geräte eingespart werden konnten.
Dies resultiert in einem geringeren Gesamtgewicht des Flugzeugs und wird zu einer Reduzierung der $CO_2$ Emissionen beitragen.

Zum anderen bildet diese Arbeit einen wichtigen Ausgangspunkt für eine längst überfällige Debatte über die Beherrschbarkeit der Komplexität zukünftiger Computersysteme.
Was passiert mit der technischen Kompetenz einer Gesellschaft, wenn die Entwicklung der zentralen Steuersysteme unserer zukünftigen Fahrzeuge in immer kürzerer Zeit durch Computer durchgeführt wird?
Besteht dann nicht die Gefahr, dass nicht nur die Anwender, sondern auch die Entwickler eines Steuersystems, dieses immer mehr als "`Black Box"' begreifen?
Ist es dann noch immer zu verantworten, dass diese Systeme immer mehr Verantwortung für unsere Sicherheit übernehmen? 

In den nächsten Abschnitten werden zunächst die einzelnen Ergebnisse der Dissertation vorgestellt.
Anschließend wird die gesellschaftliche Relevanz der gewonnenen Erkenntnisse herausgearbeitet, um eine Einordnung der Bedeutung der zugrunde liegenden Dissertation zu ermöglichen.

\section{Ergebnisse der Dissertation}
\label{sec:ergebn-der-diss}

\subsection{Aufgabenstellung}

Das Ziel der Dissertation lag in der Entwicklung eines Verfahrens, mit dem Softwarekomponenten automatisiert und ohne Einschränkung bei der Erfüllung von Zuverlässigkeitsanforderungen auf die verschiedenen Computer eines Steuersystems platziert werden können.
Dieses Verfahren sollte nicht nur die Konstruktion \emph{einer} Platzierung erlauben, sondern auch \emph{alternative Platzierungen} produzieren, so dass eine Optimierung des Gesamtsystems trotz großer Komplexität durchgeführt werden kann.
Mit Hilfe der Optimierung sollte eine hohe "`Funktionsdichte"' erzielt werden, so dass die Ressourcen der Computer, zum Beispiel die Prozessoren, möglichst \emph{gemeinsam} durch verschiedene Softwarekomponenten verwendet werden und damit eine hohe \emph{Ressourceneffizienz} erzielt wird.

\subsection{Ergebnisse}

Die Ergebnisse der Dissertation untergliedern sich in einen \emph{methodischen}, einen \emph{konzeptuellen} und einen \emph{praktischen Teil}.
Im methodischen Teil wird ein Vorgehensmodell entwickelt, das einen neuartigen Ablauf der Entwicklungsschritte beschreibt und dabei insbesondere die neuen Möglichkeiten einer automatisierten Platzierung von Softwarekomponenten berücksichtigt.

Der konzeptuelle Teil bildet das Herzstück der Arbeit.
Er enthält die im Rahmen dieser Arbeit entwickelten Formalismen, mit denen die Anforderungen und die Freiheitsgrade einer Platzierung eindeutig und maschinenlesbar spezifiziert werden können.
Hier werden auch die neuen Transformationen vorgestellt, mit deren Hilfe ein formal spezifiziertes Platzierungsproblem auf einen generischen, mathematischen Formalismus -- ein \emph{Constraint Satisfaction Problem} -- überführt werden kann.
Diese Überführung ist die Voraussetzung für den Einsatz effizienter Algorithmen, mit denen Lösungen für ein derartiges \emph{Constraint Satisfaction Problem} automatisiert erstellt werden können.

Im praktischen Teil wird die Umsetzung dieses Verfahrens in Form des Softwarewerkzeugs ASSIST dokumentiert.
ASSIST ermöglicht es einem Fachexperten mit geringen IT-Kenntnissen, das zu entwickelnde Steuersystem und dessen Anforderungen textuell zu beschreiben und anschließend eine Platzierung aller Softwarekomponenten automatisiert konstruieren zu lassen.
Eine Demonstration des Einsatzes von ASSIST am Beispiel einer Flugsteuerung für ein ziviles Verkehrsflugzeug sowie am Beispiel eines Steuersystems für ein Raumfahrzeug ist ein weiterer praktischer Bestandteil dieser Arbeit.

\subsubsection{Methodischer Teil: Ein neues Vorgehensmodell}

Die Platzierung von Softwarekomponenten ist ein wichtiger Dreh"= und Angelpunkt in der Entwicklung eines Steuersystems, denn sie repräsentiert die Ergebnisse einer Abstimmung zwischen den Möglichkeiten der Hardware"=Entwicklung und den Anforderungen der Software"=Entwicklung.
Während viele Aspekte der Entwicklung von Steuersystemen in diversen Normen und Industriestandards detailliert beschrieben sind, ist dies für die Konstruktion einer Platzierung von Softwarekomponenten nicht gegeben.
Die notwendigen Schritte zu ihrer Erstellung werden -- trotz ihrer zentralen Bedeutung für die korrekte Arbeitsweise des Steuersystems -- nicht dokumentiert.
Sie wird stattdessen als "`korrekt"' und "`vollständig vorliegend"' angenommen.

Im Rahmen der Dissertation wurden zunächst die Entwicklungsprozesse in der Praxis der Luft"= und Raumfahrt analysiert, so dass ein Katalog mit Anforderungen an ein Vorgehen zur Konstruktion einer Platzierung erstellt werden konnte.
Auf der Basis dieser Anforderungen wurde im Anschluss ein konkretes Vorgehensmodell entwickelt (siehe Abb.~\ref{fig:vorgehensmodell}).
Es beschreibt die Abfolge der notwendigen Entwicklungsaktivitäten und Informationsflüsse zur Erstellung einer Platzierung.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.9\textwidth]{gfx/vorgehen.pdf}
  \caption{Vorgehensmodell zur Konstruktion einer Platzierung}
  \label{fig:vorgehensmodell}
\end{figure}

Eine zentrale Herausforderung bei der Entwicklung des Vorgehensmodells bestand darin, die unterschiedlichen \emph{Detaillierungsgrade} der Anforderungen zu verarbeiten, denn die Konstruktion einer Platzierung erfolgt nicht nur einmalig.
Sie kann stattdessen als iterativer Prozess verstanden werden, bei dem die Ergebnisse schrittweise verfeinert und konkretisiert werden.
Am Anfang der Entwicklung eines Steuersystems liegen beispielsweise meist nur sehr grobe Informationen über die Struktur und die Bedarfe der Softwarekomponenten vor. 
Zugleich sind zu diesem Zeitpunkt meist auch erst sehr wenige Informationen über die Fähigkeiten der Prozessoren verfügbar.
Dennoch müssen bereits zu diesem Zeitpunkt grundlegende Entscheidungen zum Aufbau eines Steuersystems getroffen werden.
Zum Beispiel muss bereits zu diesem Zeitpunkt abgeschätzt werden, wieviele Computer notwendig sind, damit das Steuersystem die geforderte Zuverlässigkeit bietet.
Die Konstruktion einer Platzierung von Softwarekomponenten ist zu diesem Zeitpunkt ein wertvolles Hilfsmittel, um den Bedarf nach redundanten Computern und Prozessoren abzuschätzen.

Am Ende der Entwicklung sind die Anforderungen der Softwarekomponenten und Fähigkeiten der Prozessoren detailliert bekannt.
Die Aufgabe der Platzierung liegt dann nicht mehr in einer groben Zuordnung der Softwarekomponenten zu den Prozessoren in den verschiedenen Computern eines Steuersystems. 
Sie muss nun für jeden Prozessor, der von mehreren Softwarekomponenten benutzt wird, einen \emph{Ablaufplan} erstellen.
Dieser Ablaufplan bestimmt, welche Softwarekomponente zu welchem Zeitpunkt wieviel Rechenzeit auf dem Prozessor erhält.
Dies ist insbesondere für zeitkritische Softwarekomponenten, wie zum Beispiel die Airbagsteuerung, essentiell, denn sie können ihre Funktion nur dann erfüllen, wenn sie zum \emph{richtigen} Zeitpunkt \emph{ausreichend} Rechenzeit für ihre Ausführung erhalten.
Die Erstellung eines solchen Ablaufplans für \emph{alle} Softwarekomponenten auf \emph{allen} Prozessoren eines Steuersystems unter Beachtung \emph{aller} Anforderungen zeitkritischer Komponenten, ist sehr komplex, aufwändig und fehlerträchtig.
Ein geeignetes Vorgehensmodell muss daher sowohl in frühen Phasen mit groben Informationen als auch in späteren Entwicklungsphasen mit sehr detaillierten Informationen Unterstützung bieten.

Aufgrund dieser Anforderungen wurde die Konstruktion einer Platzierung im entwickelten Vorgehensmodell auf zwei Phasen aufgeteilt: eine \emph{räumliche} und eine \emph{zeitliche Platzierung}.
Die räumliche Platzierung wird in frühen Entwicklungsphasen durchgeführt und platziert die Softwarekomponenten primär unter Berücksichtigung ihrer Zuverlässigkeitsanforderungen auf die einzelnen Computersysteme und Prozessoren.
Es wird zu diesem Zeitpunkt beispielsweise sichergestellt, dass redundante Softwarekomponenten auch auf unterschiedlichen Prozessoren ausgeführt werden, um die Auswirkungen beim Ausfall eines Prozessors zu minimieren.
In frühen Entwicklungsphasen sind in der Regel alle notwendigen Informationen verfügbar, um diese Entscheidungen sicher treffen zu können und damit den Aufbau der grundlegenden Architektur eines Steuersystems zu begleiten.

Die zeitliche Platzierung koordiniert dagegen den Zugriff mehrerer Softwarekomponenten auf die Rechenzeit eines Prozessors in der zeitlichen Dimension.
Nach der Zuordnung der Softwarekomponenten zu den Prozessoren wird in dieser Phase ein Ablaufplan für deren Ausführung auf den Prozessoren erstellt.
Dieser Ablaufplan muss die zeitlichen Anforderungen aller Softwarekomponenten berücksichtigen und mit der Verarbeitungsgeschwindigkeit des Prozessors in Relation setzen, denn auf einem langsamen Prozessor benötigt eine Softwarekomponente wesentlich mehr Rechenzeit, um "`vollständig"' ausgeführt zu werden.

Darüber hinaus finden im entwickelten Vorgehensmodell auch zusätzliche Aktivitäten zur Analyse des Zeitverhaltens einer Softwarekomponenten auf einem spezifischen Prozessor sowie Aktivitäten zur Validierung der erstellten Platzierung Berücksichtigung.
Der Schwerpunkt der Dissertation liegt jedoch auf der Entwicklung eines Verfahrens zur Automatisierung der räumlichen und zeitlichen Platzierung von Softwarekomponenten.

\subsubsection{Konzeptioneller Teil: Formalisierung der Platzierungsproblematik}

Im konzeptionellen Teil der Arbeit werden die Grundlagen für die Automatisierung geschaffen. 
Dazu wird zunächst die Frage der Korrektheit einer Platzierung adressiert: wann kann eine Platzierung als "`fehlerfrei"' angesehen werden? 
Welche Anforderungen muss sie dazu erfüllen?

Bei Steuersystemen in Fahrzeugen sind es vor allem zwei Aspekte, die neben der reinen Funktionalität, von großer Bedeutung für dessen Korrektheit sind: \emph{Zuverlässigkeit} und \emph{Echtzeitfähigkeit}.
Zuverlässigkeit beschreibt die Robustheit des Systems in Gegenwart von Fehlern und Ausfällen, während Echtzeitfähigkeit die "`rechtzeitige"' Ausführung aller zeitkritischen Funktionen beinhaltet. 
Eine Platzierung ist daher erst dann korrekt, wenn sie alle Zuverlässigkeits"= und Echtzeitanforderungen erfüllt.
In der Dissertation wurden die relevanten Korrektheitskriterien einer Platzierung für die Aspekte Zuverlässigkeit und Echtzeitfähigkeit aus den gängigen Normen und Standards der Luft"= und Raumfahrt abgeleitet und formalisiert.
Mit Hilfe dieser Kriterien lässt sich ein Platzierungsproblem bei einem Steuersystem präzise und eindeutig beschreiben.
Dies bildet die Grundlage für den nächsten konzeptionellen Schritt: die Entwicklung eines Verfahrens zur \emph{Lösung} eines Platzierungsproblems.

Der Ansatz zur Lösung eines Platzierungsproblems besteht in dessen Modellierung als mathematisches \emph{Constraint Satisfaction Problem} -- auch Bedingungserfüllungsproblem genannt.
Dies ist eine spezielle Klasse von mathematischen Problemstellungen, bei denen für eine Menge von ganzzahligen Variablen eine gültige Belegung gesucht wird, die allen gestellten Randbedingungen (\emph{engl.: Constraints}) genügt.
Der große Vorteil dieser speziellen Modellierungsform besteht darin, dass sie rein deskriptiv erfolgt.
Es muss lediglich spezifiziert werden, welche Anforderungen eine korrekte Platzierung erfüllen muss, aber nicht, wie eine korrekte Platzierung gefunden werden kann.
Die Synthese von Lösungen wird stattdessen leistungsfähigen und sehr effizienten Algorithmen überlassen.
Der zentrale Beitrag dieser Arbeit besteht daher in der Modellierung eines räumlichen und zeitlichen Platzierungsproblems als \emph{Constraint Satisfaction Problem}.
Dies ist die Voraussetzung, um die konstruktiv"=kreative Tätigkeit der Platzierung von Softwarekomponenten mit Hilfe eines Computers zu automatisieren.

Die Konstruktion einer korrekten -- und damit realisierbaren -- Platzierung ist in der Praxis noch nicht ausreichend.
Eine Platzierung muss darüber hinaus auch verschiedenen projektspezifischen Optimierungskriterien genügen.
Sie muss beispielsweise die zukünftige Erweiterbarkeit des Steuersystems erleichtern, in dem sie die verfügbaren Ressourcen nicht zu 100\% auslastet, um eine Reserve für zukünftige funktionale Erweiterungen bei den Softwarekomponenten zu schaffen.
Die Herausforderung besteht daher in der Konstruktion einer korrekten \emph{und} optimierten Platzierung.

Obwohl bereits äußerst effiziente Algorithmen zur Lösung eines Platzierungsproblems eingesetzt werden, ist der vorliegende Lösungsraum bei realistischen Steuersystemen noch immer zu groß, um in sinnvollen Zeiträumen \emph{vollständig} durchsucht zu werden und damit eine korrekte und optimale Platzierung zu finden.
Selbst bei einem kleinen System mit nur 10 Prozessoren und lediglich 25 Softwarekomponenten gibt es theoretisch bereits $10^{25}$ Platzierungsmöglichkeiten für die einzelnen Softwarekomponenten.
Selbstverständlich sind nicht alle Platzierungen realisierbar und in Hinblick auf die gestellten Optimierungskriterien geeignet, aber welche dieser Lösungen wären es?
Selbst wenn man jede Möglichkeit innerhalb einer Hundertstelsekunde diesbezüglich analysieren könnte, würde es noch immer mehr als $3~170~979~198~376~458$ Jahre dauern, bis man den vorliegenden Lösungsraum \emph{vollständig} durchsucht hat.
Aus diesem Grund wurden im Rahmen der Dissertation hochoptimierte Strategien und spezielle Heuristiken entwickelt, mit denen auch bei einer \emph{unvollständigen} Durchsuchung des Lösungsraums, möglichst viele korrekte und zugleich auch "`gute"' Platzierungen gefunden werden.
 
\subsubsection{Praktischer Teil: Softwarewerkzeug und Fallbeispiele}

Im Rahmen der Dissertation sind auch konkrete, praktische Ergebnisse erzielt worden, um die Realisierbarkeit der konzeptionellen Beiträge nachzuweisen.
Dazu wurde das entwickelte Verfahren zur Platzierung von Softwarekomponenten als Softwarewerkzeug mit dem Namen  \emph{Architecture Synthesis for Safety Critical Systems - ASSIST} implementiert (siehe Abb.~\ref{fig:assist}).
Mit Hilfe von ASSIST kann der Entwickler eines Steuersystems sein vorliegende Platzierungsproblem \emph{textuell} beschreiben.
Die Grammatik dieser Eingabesprache erlaubt die Spezifikation einer Vielzahl von unterschiedlichen Platzierungsproblemen und orientiert sich an den feststehenden Begrifflichkeiten der Systemarchitekturen in der Luft"= und Raumfahrt.
Dies erleichtert die Verwendung des Werkzeugs für Fachexperten aus diesem Bereich deutlich.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{gfx/assist.jpg}
  \caption{Screenshot des Werkzeugs ASSIST}
  \label{fig:assist}
\end{figure}

Für ein derart spezifiziertes Platzierungsproblem generiert das Werkzeug ASSIST automatisch ein äquivalentes Constraint Satisfaction Problem.
Mit Hilfe der speziellen Strategien und Heuristiken werden im Anschluss Lösungen gesucht.
Der Anwender kann die gefundenen Platzierungen nach verschiedenen Kriterien automatisiert bewerten lassen und damit innerhalb von wenigen Minuten auf einem regulären Desktop"=Computer korrekte und optimierte Platzierungen für komplexe Steuersysteme erhalten.
Die Abläufe im Hintergrund und die Struktur des Lösungsraums sind vor dem Anwender vollständig verborgen. 
Seine Aufgabe beschränkt sich auf die vollständige Spezifikation des Platzierungsproblems und auf die anschließende Auswahl der automatisch bewerteten Lösungsalternativen.

Die Anwendung des entwickelten Verfahrens und der Einsatz der Werkzeugs ASSIST wird anhand von zwei Steuersystemen mit hohen Zuverlässigkeits"= und Echtzeitanforderungen demonstriert.
Im ersten Fallbeispiel wird die Architektur eines Flugleitsystems betrachtet. Die besondere Herausforderung liegt hier in der korrekten Berücksichtigung aller Redundanzanforderungen, um die geforderte Zuverlässigkeit des Systems zu gewährleisten.
In Abhängigkeit von der Kritikalität der Funktion eines Steuersystems, kann eine Redundanz mit Hilfe von gleichartigen Softwarekomponenten, die auf unterschiedlichen Prozessoren ausgeführt werden, nicht mehr ausreichend sein.
Bei besonders kritischen Funktionen muss ein hohes Maß an \emph{Dissimilarität} zwischen den redundanten Softwarekomponenten erzielt werden, um die Auswirkungen von unentdeckten Fehlern zu minimieren.
Konkret bedeutet dies, dass die jeweiligen Softwarekomponenten zunächst von unterschiedlichen Teams entwickelt und getestet werden müssen.
Darüber hinaus müssen die Softwarekomponenten aber auch auf \emph{unterschiedlichen} Prozessoren von \emph{unterschiedlichen} Herstellern ausgeführt werden, um eine möglichst hohe Zuverlässigkeit zu gewährleisten.
Die Platzierung von Softwarekomponenten muss diese Anforderungen ebenfalls berücksichtigen und geeignete Prozessoren zur Ausführung der redundanten Softwarekomponenten auswählen.

Das zweite Fallbeispiel befasst sich mit der Architektur eines Steuersystems für Raumfahrzeuge.
Hier liegt der Fokus auf der richtigen Behandlung von Softwarekomponenten, die aus mehr als einem Kontrollfluss bestehen und die parallel arbeitenden Kerne moderner Prozessoren ausnutzen \emph{müssen}, um die erforderliche Leistung zu erbringen.
Darüber hinaus werden hier auch die Herausforderungen eines Systems mit unterschiedlichen Ressourcenkonfigurationen für unterschiedliche Betriebsmodi adressiert.
In Abhängigkeit von der Flugphase eines Raumfahrzeugs werden die Prozessoren eines Steuersystems beispielsweise unterschiedlich genutzt. 
Sie können entweder zur Steigerung der Zuverlässigkeit oder zur Erhöhung der Rechenleistung eingesetzt werden, indem notwendige Berechnungen entweder auf mehreren Prozessoren oder nur auf einem Prozessor durchgeführt werden.
Dieses Fallbeispiel belegt, dass Platzierungen von Softwarekomponenten für die unterschiedlichen Ressourcenkonfigurationen in kurzer Zeit erstellt und optimiert werden können, so dass sich die Entwicklungszeit eines derartigen Steuersystems signifikant verkürzt.

\section{Gesellschaftliche Bedeutung}
\label{sec:gesellsch-bede}


Zunächst die Bedeutung für Industrie:
\begin{itemize}
\item Arbeit schlägt die Brücke zwischen der Theorie und Praxis
\item Werkzeug erlaubt es auch einem Fachexperten, die Forschritte aus dem Bereich der Informatik nutzen zu können
\item ASSIST ist frei verfügbar; Quellcode ist offen und für jeden nutzbar
\item Nächster Schritt: Gründung eines Industriekonsortiums unter dem Dach der Eclipse Foundation
\item Zunächst kann damit die Entwicklung von Systemen beschleunigt werden
\item Systeme können optimiert werden, so dass weniger Ressourcen benötigt werden 
\item Weniger Fehler im System 
\item Optimierungen sind zugänglich, die bisher aufgrund der hohen Komplexität nicht möglich waren - damit weniger CO2, weniger Gewicht, effizientere Systeme, ...
\item Konkret zeigt sich dies auch beim Einsatz von ASSIST bei einem großen Flugzeughersteller
\end{itemize}

Aber, diese Arbeit ist ein guter Gegenstand, um Fragen nach der Beherrschbarkeit heutiger Technologien zu stellen und zu diskutieren

\begin{itemize}
\item Was sind die Nachteile die sich daraus ergeben?
\item Ist es nicht sinnvoll, wenn sich Menschen so lange mit den Anforderungen beschäftigen?
\item Geben wir damit nicht die Kompetenz über den Bau von Dingen ab?
\item Sollten wir Dinge konstruieren und nutzen, deren Aufbau das Verständnis des Menschen übersteigt?
\item Meta-Programmer - eine kleine Elite erstellt die Algorithmen, deren Komplexität sich dem Verständnis einem Großteil der Bevölkerung entzieht. Diese Algorithmen bauen aber die Maschinen und Systeme für den Rest der Menschheit - automatisch! Ist das nicht eine Gefahr für die Demokratie?
\item Unter dem Stichwort "`Industrie 4.0"' steht die Vernetzung und Automatisierung Produktionsbranchen vor der Tür. Wer kann diese Komplexität der vernetzten Produktionsketten überblicken? 
\item ...
\item Welche Fragen müsste man noch damit aufwerfen?
\end{itemize}


\end{document}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
